(* ::Package:: *)

(* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ *)

(* :Title: FCLoopCanonicalize												*)

(*
	This software is covered by the GNU General Public License 3.
	Copyright (C) 1990-2018 Rolf Mertig
	Copyright (C) 1997-2018 Frederik Orellana
	Copyright (C) 2014-2018 Vladyslav Shtabovenko
*)

(* :Summary:  Canonicalizes indices of 1-loop integrals						*)

(* ------------------------------------------------------------------------ *)

FCLoopCanonicalize::usage = "FCLoopCanonicalize[expr,q,loopHead] is an auxiliary \
internal function that canonicalizes indices of 1-loop integrals \
with loop momentum q that are wrapped inside loopHead. The output is given as a \
list of four entries, from which the last one contains a list of all the unique \
1-loop integrals in the given expression. After those are simplified, the original \
output of FCLoopCanonicalize together with the list of the simplified unique \
integrals should be inserted into FCLoopSolutionList to obtain the final \
replacement list that will be applied to the original expression."

FCLoopCanonicalize::fail =
"Error! FCLoopCanonicalize failed to canonicalize loop integrals in `1`!";

FCLoopCanonicalize::notunique =
"Error! The random index generated by FCLoopCanonicalize already appears in the expression!";

FCLoopCanonicalize::nonloop =
"Error! The expression `1` contains non-loop terms wrapped with the head `2`!";

Begin["`Package`"]
End[]

Begin["`FCLoopCanonicalize`Private`"]

Options[FCLoopCanonicalize] = {
	FCI -> False,
	PaVeIntegralHeads -> FeynCalc`Package`PaVeHeadsList
};

FCLoopCanonicalize[expr_, q_, head_, OptionsPattern[]] :=
	Block[ {ex, loopList, repIndexList, reversedRepIndexList,
	canIndexList, uniqueCanIndexList, null1, null2, seed,res, loopIntHeads},
		seed = ToString[Unique["li"]];
		loopIntHeads = OptionValue[PaVeIntegralHeads];

		If[	!FreeQ2[{expr}, FeynCalc`Package`NRStuff],
			Message[FeynCalc::nrfail];
			Abort[]
		];

		(*This is the list of all the loop integrals in the expression.*)
		If[ OptionValue[FCI],
			ex = expr,
			ex = FCI[expr]
		];
		If[ !FreeQ[ex,seed],
			Message[FCLoopCanonicalize::notunique];
			Abort[]
		];
		loopList = Union[Cases[ex + null1 + null2, head[_] , Infinity]];
		If[ Cases[loopList, head[x_]/;FreeQ2[x,Join[{q},loopIntHeads]] , Infinity]=!={},
			Message[FCLoopCanonicalize::nonloop, expr, head];
			Abort[]
		];
		(*	Here we collect the tensor indices of each integral from the
			previous list	*)
		repIndexList =
			((MapIndexed[Rule[#1,LorentzIndex[FCGV[(seed <> ToString[Identity @@ #2])], (#1/.LorentzIndex[_,dim_:4]:>dim)]] &, Cases[#,
				Pair[x_, LorentzIndex[y__]] /; ! FreeQ[x, q] :>
					LorentzIndex[y], Infinity] // Union] // Flatten) & /@
			loopList);
		(*	This is the list of all the loop tensor integrals with
			canonicalized indices.	*)
		canIndexList = (MapIndexed[(#1 /. First[repIndexList[[#2]]]) &,
			loopList]);
		reversedRepIndexList = Map[(Reverse /@ #) &, repIndexList];

		(*	Finally we obtain the (usually much smaller) list of all the
			unique tensor integrals.Only those need to be reduced.*)
		uniqueCanIndexList = canIndexList // DeleteDuplicates;

		(* Final cross-check to ensure that we didn't mess anything up *)
		res = {loopList, reversedRepIndexList, canIndexList, uniqueCanIndexList};
		If [(ex/. head->Identity) =!= (ex/.FCLoopSolutionList[res, (res[[4]]/. head->Identity)]),
			Message[FCLoopCanonicalize::fail,expr];
			Print[(ex/. head->Identity)];
			Print[(ex/.FCLoopSolutionList[res, (res[[4]]/. head->Identity)])];
			Print[FCLoopSolutionList[res, (res[[4]]/. head->Identity)]];
			Abort[]
		];

		res
	]



FCPrint[1,"FCLoopCanonicalize.m loaded."];
End[]
